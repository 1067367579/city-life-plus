# City-life-Plus - 高并发本地生活服务电商平台

> 本文档旨在深度剖析项目的架构设计思想、高并发实现策略以及分布式系统的核心设计考量。

## 目录

- [架构设计总览](#架构设计总览)
- [核心设计思想](#核心设计思想)
- [高并发秒杀系统架构](#高并发秒杀系统架构)
- [分布式锁深度设计](#分布式锁深度设计)
- [缓存体系架构](#缓存体系架构)
- [CAP特性与一致性保障](#cap特性与一致性保障)
- [中间件特性运用](#中间件特性运用)
- [核心业务链路分析](#核心业务链路分析)
- [技术栈详解](#技术栈详解)
- [项目结构](#项目结构)

---

## 架构设计总览

### 分层架构设计

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              应用层 (Application Layer)                          │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Controller 层 │ 拦截器层 │ 异常处理层                                    │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                              业务层 (Business Layer)                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Service 层 (业务编排) │ 事务管理 │ 缓存策略 │ 消息发送                   │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                              基础设施层 (Infrastructure Layer)                  │
│  ┌───────────────┬───────────────┬───────────────┬───────────────┐            │
│  │   MySQL       │    Redis      │   RabbitMQ    │   阿里云 OSS   │            │
│  │  (数据持久化)  │  (缓存/会话)   │  (异步解耦)    │  (文件存储)    │            │
│  └───────────────┴───────────────┴───────────────┴───────────────┘            │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 架构设计原则

| 原则 | 体现 | 收益 |
|------|------|------|
| **职责分离** | Controller 负责参数校验与响应，Service 负责业务逻辑 | 代码可维护性强 |
| **面向接口编程** | Service 接口定义 + 实现类分离 | 便于扩展和替换 |
| **关注点分离** | 缓存逻辑、消息逻辑、业务逻辑各自独立 | 降低耦合度 |
| **约定大于配置** | 统一返回格式 Result、统一异常处理 | 开发效率提升 |

---

## 核心设计思想

### 1. 读写分离与缓存优先策略

```
查询请求 ──┬──> 缓存命中 ──> 直接返回 (毫秒级响应)
           │
           └──> 缓存未命中 ──> 数据库查询 ──> 更新缓存 ──> 返回
```

**核心思想：** 读操作优先查询缓存，只有缓存未命中时才访问数据库。写操作采用**删除缓存策略**（而非更新缓存），避免复杂的缓存同步问题。

### 2. 异步解耦与削峰填谷

```
高并发请求 ──> 快速校验 ──> 消息队列 ──> 异步处理 ──> 数据库持久化
              (Lua脚本)    (RabbitMQ)    (消费者)

优势：请求响应时间从 100ms+ 降至 10ms 以内
```

**核心思想：** 将非关键路径的操作（订单创建、库存扣减）异步化，主流程仅做校验和消息投递。

### 3. 分层防御与多重保障

```
                    ┌─────────────────────────────────────┐
                    │           第一层：网关层             │
                    │     拦截非法请求、频率限制           │
                    └─────────────────────────────────────┘
                              │
                    ┌─────────────────────────────────────┐
                    │           第二层：应用层             │
                    │     参数校验、业务规则校验           │
                    └─────────────────────────────────────┘
                              │
                    ┌─────────────────────────────────────┐
                    │           第三层：数据层             │
                    │     唯一索引、分布式锁、事务         │
                    └─────────────────────────────────────┘
```

**核心思想：** 不依赖单点防御，而是在每一层都设置关卡，任意一层失效不会导致系统崩溃。

### 4. 最终一致性而非强一致性

```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│    缓存       │ ◄──► │   消息队列    │ ◄──► │   数据库      │
└──────────────┘     └──────────────┘     └──────────────┘
      │                                         │
      └────────────── 最终一致性 ───────────────┘
```

**核心思想：** 在高并发场景下，牺牲短暂的强一致性，换取更高的可用性和吞吐量。通过消息队列的重试机制、幂等设计保证最终一致性。

---

## 高并发秒杀系统架构

### 秒杀核心挑战

1. **超卖问题**：多个线程同时读取到库存>0，导致超卖
2. **重复下单**：同一用户多次提交订单
3. **性能瓶颈**：数据库连接池耗尽
4. **雪崩效应**：瞬时高流量击垮整个系统

### 秒杀架构设计

```
                           ┌─────────────────────────────┐
                           │      用户请求 (高并发)       │
                           └──────────────┬──────────────┘
                                          │
                           ┌──────────────▼──────────────┐
                           │   1. Lua 脚本原子校验       │
                           │   • 库存是否充足            │
                           │   • 是否重复下单            │
                           │   • 原子扣减库存            │
                           └──────────────┬──────────────┘
                                          │
                    ┌─────────────────────┼─────────────────────┐
                    │                     │                     │
           ┌────────▼────────┐   ┌────────▼────────┐   ┌────────▼────────┐
           │  库存不足 (1%)   │   │  重复下单 (2%)   │   │  校验通过 (97%)  │
           └─────────────────┘   └─────────────────┘   └────────┬─────────┘
                                                                 │
                                                                 ▼
                                                   ┌─────────────────────────────┐
                                                   │   2. 生成订单ID (Redis ID Worker)  │
                                                   └──────────────┬──────────────┘
                                                                  │
                                                                  ▼
                                                   ┌─────────────────────────────┐
                                                   │   3. 投递消息到 RabbitMQ    │
                                                   │      (异步创建订单)          │
                                                   └──────────────┬──────────────┘
                                                                  │
                                                                  ▼
                                                   ┌─────────────────────────────┐
                                                   │   4. OrderConsumer 消费     │
                                                   │   • 双重校验 (DB层面)       │
                                                   │   • 分布式锁 (Redisson)     │
                                                   │   • 事务写入订单表           │
                                                   └─────────────────────────────┘
```

### Lua 脚本设计（第一道防线）

```lua
-- seckill.lua - 秒杀校验脚本
-- 设计思路：将多个操作合并为原子操作，避免并发问题

-- 参数：ARGV[1]=优惠券ID, ARGV[2]=用户ID
local voucherId = ARGV[1]
local userId = ARGV[2]

-- Key 设计
local stockKey = 'seckill:stock:' .. voucherId      -- 库存Key
local orderKey = 'seckill:order:' .. voucherId      -- 订单用户集合

-- 1. 库存检查
local stock = redis.call('get', stockKey) or '0'
if tonumber(stock) < 1 then
    return 1  -- 库存不足
end

-- 2. 检查是否重复下单 (使用 Set 数据结构)
if redis.call('sismember', orderKey, userId) == 1 then
    return 2  -- 已下单
end

-- 3. 扣减库存 (INCRBY 支持负数)
redis.call('incrby', stockKey, -1)

-- 4. 记录下单用户 (Set 保证唯一性)
redis.call('sadd', orderKey, userId)

return 0  -- 成功
```

**Lua 脚本设计精髓：**
- **原子性**：Redis 执行 Lua 脚本时是单线程的，所有操作原子执行
- **高效性**：网络往返次数从 4 次降为 1 次
- **避免竞态**：库存检查和扣减不会被打断

### 消息队列设计（第二道防线）

```java
// OrderProducer.java - 消息投递
public void produceOrder(CreateOrderDTO createOrderDTO) {
    // 发送订单创建消息到队列
    rabbitTemplate.convertAndSend(
        RabbitConstants.SECKILL_QUEUE_NAME,
        createOrderDTO
    );
}

// OrderConsumer.java - 消息消费
@RabbitListener(queues = RabbitConstants.SECKILL_QUEUE_NAME)
public void consumerOrder(CreateOrderDTO dto) {
    // 1. 获取分布式锁 (Redisson)
    RLock lock = redissonClient.getLock("order:lock:" + dto.getUserId());

    // 2. 双重校验：DB 层面再次检查
    Long count = voucherOrderMapper.selectCount(
        new LambdaQueryWrapper<VoucherOrder>()
            .eq(VoucherOrder::getVoucherId, dto.getVoucherId())
            .eq(VoucherOrder::getUserId, dto.getUserId())
    );

    // 3. 使用代理对象调用 @Transactional 方法
    OrderConsumer proxy = (OrderConsumer) AopContext.currentProxy();
    proxy.createOrder(dto.getVoucherId(), dto.getOrderId(), dto.getUserId());
}
```

**消息队列设计精髓：**
- **削峰填谷**：高峰期请求积压在队列，平滑处理
- **异步解耦**：主流程快速响应，用户无需等待订单创建完成
- **多重保障**：Lua 脚本已校验一次，消费者内再次校验
- **事务保证**：使用 `@Transactional` + 代理对象确保事务生效

---

## 分布式锁深度设计

### 分布式锁的必要性

在分布式系统中，多个服务实例可能同时访问同一资源，必须保证同一时刻只有一个实例能获取到资源。

### 锁的设计演进

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           分布式锁实现演进                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  阶段1：基本实现                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  SET key value NX EX 30                                                 │   │
│  │  问题：删除操作不是原子性的，可能误删他人的锁                             │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                      │                                          │
│                                      ▼                                          │
│  阶段2：UUID 标识防止误删                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  SET key uuid NX EX 30                                                  │   │
│  │  删除前先判断：if get(key) == uuid then del(key)                        │   │
│  │  问题：判断和删除不是原子操作，仍有竞态                                   │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                      │                                          │
│                                      ▼                                          │
│  阶段3：Lua 脚本原子操作                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  if redis.call('get', KEYS[1]) == ARGV[1] then                          │   │
│  │      return redis.call('del', KEYS[1])                                  │   │
│  │  end                                                                     │   │
│  │  return 0                                                               │   │
│  │  ✓ 判断和删除原子化，安全可靠                                            │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                      │                                          │
│                                      ▼                                          │
│  阶段4：Redisson 框架 (生产级方案)                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  • 看门狗自动续期 (无需手动设置 TTL)                                     │   │
│  │  • 支持公平锁、读写锁、红锁等多种锁类型                                  │   │
│  │  • 底层已处理好各种边界情况                                              │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### SimpleRedisLock 实现（自研方案）

```java
public class SimpleRedisLock implements ILock {

    private static final String LOCK_PREFIX = "lock:";
    // 进程唯一标识 + 线程ID，确保锁的持有者标识唯一
    private static final String PROCESS_ID = UUID.randomUUID().toString();

    // Lua 脚本：原子解锁
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;

    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    public boolean tryLock(Long expireTime) {
        // SET key value NX EX (原子设锁)
        return BooleanUtil.isTrue(
            stringRedisTemplate.opsForValue().setIfAbsent(
                LOCK_PREFIX + name,
                PROCESS_ID + Thread.currentThread().getId(),
                expireTime,
                TimeUnit.SECONDS
            )
        );
    }

    public void unlock() {
        // 使用 Lua 脚本原子删除
        stringRedisTemplate.execute(
            UNLOCK_SCRIPT,
            Collections.singletonList(LOCK_PREFIX + name),
            PROCESS_ID + Thread.currentThread().getId()
        );
    }
}
```

### Redisson 方案（框架方案）

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        // 单节点模式
        config.useSingleServer()
              .setAddress("redis://localhost:6379");
        return Redisson.create(config);
    }
}

// 使用方式
@Autowire
private RedissonClient redissonClient;

public void seckill() {
    // 获取锁（带看门狗自动续期）
    RLock lock = redissonClient.getLock("order:lock:" + userId);

    boolean acquired = lock.tryLock();
    if (!acquired) {
        throw new BusinessException("请勿重复提交");
    }

    try {
        // 业务逻辑
        createOrder();
    } finally {
        lock.unlock();  // 自动释放
    }
}
```

### 锁的设计权衡

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **SimpleRedisLock** | 轻量、无外部依赖 | 需手动管理 TTL | 简单场景、演示项目 |
| **Redisson** | 看门狗续期、功能丰富 | 引入额外依赖 | 生产环境、高要求场景 |

---

## 缓存体系架构

### 缓存面临的核心问题

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           缓存三大难题                                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  1. 缓存穿透 (Cache Penetration)                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  请求 ──> 缓存(无) ──> DB(无) ──> 返回空                                 │   │
│  │  问题：恶意用户大量请求不存在的key，击穿DB                                 │   │
│  │  解决：空值缓存 (缓存空对象，TTL较短)                                      │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  2. 缓存击穿 (Cache Breakdown)                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  热点key过期瞬间 ──> 大量请求同时涌入DB                                   │   │
│  │  问题：瞬时DB压力骤增                                                     │   │
│  │  解决：逻辑过期 + 互斥锁 / 单线程重建                                      │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  3. 缓存雪崩 (Cache Avalanche)                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  大量key同时过期 ──> 大量请求同时涌入DB                                   │   │
│  │  问题：DB瞬间压力过大崩溃                                                 │   │
│  │  解决：随机过期时间 + 逻辑过期 + 多级缓存                                  │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 缓存架构设计

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              多级缓存架构                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  请求 ──> ┌────────────────┐                                                   │
│           │  1. 本地缓存    │  Caffeine (L1)                                    │
│           │  10ms 响应     │                                                   │
│           └───────┬────────┘                                                   │
│                   │ 命中                                                       │
│                   ▼                                                            │
│           ┌────────────────┐                                                   │
│           │  2. Redis缓存   │  分布式缓存 (L2)                                  │
│           │  1ms 响应      │                                                   │
│           └───────┬────────┘                                                   │
│                   │ 命中                                                       │
│                   ▼                                                            │
│           ┌────────────────┐                                                   │
│           │  3. MySQL       │  数据库 (L3)                                     │
│           │  10-100ms 响应  │                                                   │
│           └────────────────┘                                                   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### RedisData 结构设计

```java
@Data
public class RedisData {
    // 业务数据
    private Object data;
    // 逻辑过期时间
    private LocalDateTime expireTime;
}
```

**设计思路：**
- 物理过期时间由 Redis 本身控制（TTL）
- 逻辑过期时间存储在 Value 中，由业务代码判断
- 即使数据过期，也返回旧数据给用户，同时异步刷新缓存

### 逻辑过期实现（解决缓存击穿）

```java
public <R, ID> R getWithLogicalExpire(String key, String lockKey, Class<R> clazz,
    ID id, Function<ID, R> getFromDB, Long expireTime, TimeUnit timeUnit) {

    // 1. 查询缓存
    String json = stringRedisTemplate.opsForValue().get(key);

    if (StrUtil.isNotEmpty(json)) {
        RedisData redisData = JSON.parseObject(json, RedisData.class);

        // 2. 判断是否逻辑过期
        if (redisData.getExpireTime().isBefore(LocalDateTime.now())) {
            // 3. 已过期：尝试获取锁，异步刷新
            if (tryLock(lockKey)) {
                // 获取锁成功：异步刷新缓存
                REFRESH_CACHE_THREAD_POOL.submit(() -> {
                    try {
                        saveObject2Redis(key, id, getFromDB, expireTime, timeUnit);
                    } finally {
                        unlock(lockKey);
                    }
                });
            }
            // 4. 返回旧数据（即使过期也返回，用户无感知）
            return JSON.parseObject(redisData.getData().toString(), clazz);
        }
        // 未过期：直接返回
        return JSON.parseObject(redisData.getData().toString(), clazz);
    }

    // 缓存未命中：查询DB并回填
    R result = getFromDB.apply(id);
    if (result == null) {
        // 空值缓存解决穿透
        this.set(key, "", 2L, TimeUnit.MINUTES);
        return null;
    }

    // 写入缓存（带逻辑过期）
    this.setWithLogicalExpire(key, result, expireTime, timeUnit);
    return result;
}
```

### 缓存 Key 设计规范

| 前缀 | 用途 | 数据结构 | TTL |
|------|------|----------|-----|
| `login:code:` | 验证码 | String | 5分钟 |
| `login:token:` | 用户会话 | Hash | 30分钟(自动续期) |
| `shop:cache:` | 商户缓存 | String(RedisData) | 30分钟(逻辑) |
| `shop:lock:` | 商户缓存锁 | String | 10秒 |
| `seckill:stock:` | 秒杀库存 | String | 活动结束 |
| `seckill:order:` | 秒杀订单用户 | Set | 活动结束 |
| `blog:like:` | 博客点赞用户 | ZSet | 永久 |
| `feed:` | 用户动态流 | ZSet | 7天 |
| `user:sign:` | 用户签到 | Bitmap | 滚动30天 |

---

## CAP 特性与一致性保障

### CAP 定理回顾

```
                    ┌─────────────────────────────────────┐
                    │                                     │
           ┌────────┴────────┐               ┌───────────┴───────────┐
           │                │               │                       │
           │    一致性       │               │      可用性            │
           │   (Consistency) │               │   (Availability)      │
           │                │               │                       │
           │  所有节点看到    │               │  每次请求都能在        │
           │  相同的数据     │               │  合理时间内获得响应    │
           └───────┬────────┘               └───────────┬───────────┘
                   │                                    │
                   │              ┌─────────────────────┘
                   │              │
                   │              ▼
                   │
           ┌───────▼───────────────────────────────────────┐
           │                                             │
           │              分区容错性                       │
           │         (Partition Tolerance)               │
           │                                             │
           │    系统在网络分区时仍能继续运行               │
           │                                             │
           └─────────────────────────────────────────────┘

           CAP 不可能三角：只能同时满足两个
```

### 本项目的 CAP 权衡

| 特性 | 权衡结果 | 说明 |
|------|----------|------|
| **C (一致性)** | 放弃强一致，选择最终一致 | 缓存与 DB 短暂不一致，但最终同步 |
| **A (可用性)** | 优先保证 | 系统始终可用，缓存故障不影响查询 |
| **P (分区容错)** | 必须保证 | 分布式系统网络分区不可避免 |

**设计决策：AP 系统**

```
本项目选择：CP  ╳          选择：AP  ✓
             ╱  ╲                      ╱  ╲
            ╱    ╲                    ╱    ╲
           CP    CA                  AP    CP

理由：
1. 用户体验优先：宁可返回旧数据，不可拒绝服务
2. 业务容忍：评论、商户信息短暂不一致可接受
3. 恢复机制：缓存故障时降级到数据库查询
```

### 一致性保障策略

#### 1. 缓存与数据库一致性

```
写入流程：
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  更新 DB     │───>│  删除缓存    │───>│  业务处理    │───>│  重建缓存    │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
       │                  │                                    │
       │                  │                                    │
       └──────────────────┴────────────────────────────────────┘
                    删除而非更新

理由：删除缓存的代价远低于更新缓存，且能避免"并发更新"导致的脏数据
```

**风险与应对：**

| 风险场景 | 发生概率 | 应对措施 |
|----------|----------|----------|
| 并发读写：先删缓存再更新DB | 低 | 延迟双删 + 适当休眠 |
| 更新DB前缓存已过期 | 低 | 依赖TTL自然过期 |
| 删除失败 | 低 | 重试机制 + 告警监控 |

#### 2. 分布式锁一致性

```java
// SimpleRedisLock 使用 UUID+ThreadId 防止误删
private static final String PROCESS_ID = UUID.randomUUID().toString();

public void unlock() {
    // Lua脚本：只有持有者才能删除自己的锁
    stringRedisTemplate.execute(
        UNLOCK_SCRIPT,
        Collections.singletonList(LOCK_PREFIX + name),
        PROCESS_ID + Thread.currentThread().getId()  // 必须是持有者
    );
}
```

#### 3. 消息队列幂等性

```java
@RabbitListener(queues = RabbitConstants.SECKILL_QUEUE_NAME)
public void consumerOrder(CreateOrderDTO dto) {
    // 1. 分布式锁：防止并发消费
    RLock lock = redissonClient.getLock("order:lock:" + dto.getUserId());

    // 2. 数据库唯一索引：防止重复插入
    // tb_voucher_order 表有 user_id + voucher_id 联合唯一索引

    // 3. 再次校验：确保不重复下单
    Long count = voucherOrderMapper.selectCount(
        new LambdaQueryWrapper<VoucherOrder>()
            .eq(VoucherOrder::getVoucherId, dto.getVoucherId())
            .eq(VoucherOrder::getUserId, dto.getUserId())
    );

    if (count > 0) {
        return;  // 已存在，直接丢弃消息
    }

    // 创建订单...
}
```

**幂等多重保障：**
1. **分布式锁**：同一用户同时只有一条消息能处理
2. **数据库唯一索引**：重复插入会报错
3. **业务层校验**：消费前再次检查订单是否存在

---

## 中间件特性运用

### Redis 特性深度运用

| Redis 特性 | 应用场景 | 实现方式 |
|------------|----------|----------|
| **String** | 验证码、Token、库存 | `SET key value EX ttl` |
| **Hash** | 用户会话存储 | `HSET key field value` |
| **Set** | 秒杀订单用户集合 | `SADD key member` |
| **ZSet** | 点赞排行、Feed流 | `ZADD key score member` |
| **Bitmap** | 用户签到 | `SETBIT key offset value` |
| **Geo** | 附近商户查询 | `GEOADD / GEORADIUS` |
| **Lua** | 秒杀原子校验、分布式锁 | `EVAL script keys[] args[]` |

### Redis GEO 实现附近商户

```java
public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) {
    // 1. GEOADD (项目启动时预加载)
    // stringRedisTemplate.opsForGeo().add("shop:geo:" + typeId,
    //     new Point(shop.getX(), shop.getY()), shop.getId().toString());

    // 2. GEORADIUS (按距离查询)
    GeoResults<RedisGeoCommands.GeoLocation<String>> search =
        stringRedisTemplate.opsForGeo().search(
            "shop:geo:" + typeId,
            GeoReference.fromCoordinate(x, y),
            new Distance(5000, RedisGeoCommands.DistanceUnit.METERS),
            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs()
                .includeDistance()    // 返回距离
                .limit(to)            // 限制数量
        );

    // 3. 按距离排序返回
    List<Shop> shops = ...
    shops.forEach(shop -> shop.setDistance(distance.getValue()));

    return Result.ok(shops);
}
```

### RabbitMQ 特性深度运用

| RabbitMQ 特性 | 应用场景 | 配置 |
|---------------|----------|------|
| **Queue** | 秒杀订单队列 | 持久化 `durable=true` |
| **Message Converter** | 消息序列化 | Jackson2JsonMessageConverter |
| **ACK** | 消息确认 | 自动确认 |
| **Direct Exchange** | 消息路由 | 默认交换器 |

```java
@Configuration
public class RabbitConfig {

    @Bean
    public Queue seckillQueue() {
        // 开启队列持久化：重启后队列不丢失
        return new Queue(RabbitConstants.SECKILL_QUEUE_NAME, true);
    }

    @Bean
    public Jackson2JsonMessageConverter messageConverter() {
        // JSON序列化：支持复杂对象传输
        return new Jackson2JsonMessageConverter();
    }
}
```

### Redisson 分布式锁特性

| 特性 | 说明 | 代码体现 |
|------|------|----------|
| **看门狗** | 自动续期防止锁过期 | `lock.lock()` 自动续约 |
| **公平锁** | 按请求顺序获取锁 | `fairLock()` |
| **读写锁** | 读写分离锁 | `readLock()` / `writeLock()` |
| **联锁** | 多把锁同时加锁 | `multiLock()` |

---

## 核心业务链路分析

### 1. 用户登录链路

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              用户登录流程                                        │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  POST /user/login                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  1. 参数校验 (正则验证邮箱格式)                                          │   │
│  │  2. 验证码校验 (Redis中获取并比对)                                       │   │
│  │  3. 用户查询 (MySQL)                                                    │   │
│  │  4. 密码比对 (BCrypt)                                                   │   │
│  │  5. Token生成 (UUID)                                                    │   │
│  │  6. 用户信息存入Redis Hash                                              │   │
│  │  7. 返回Token                                                           │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  Token 存储结构：                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Key: login:token:<tokenId>                                            │   │
│  │  Type: Hash                                                            │   │
│  │  Fields:                                                               │   │
│  │    - id: 用户ID                                                        │   │
│  │    - nickName: 昵称                                                    │   │
│  │    - icon: 头像URL                                                     │   │
│  │    - createTime: 创建时间                                              │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 2. 请求拦截链路（双层拦截器）

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           请求拦截器链                                           │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  请求 ──> RefreshInterceptor (order=0) ──> LoginInterceptor (order=1)         │
│           │                                        │                            │
│           │  1. 获取Authorization头                 │  1. 检查UserHolder        │
│           │  2. 从Redis获取用户信息                 │  2. 为空返回401           │
│           │  3. 存入ThreadLocal                     │  3. 请求结束后清理        │
│           │  4. 刷新过期时间(30分钟)                │                            │
│           │                                        │                            │
│           ▼                                        ▼                            │
│      放行通过                                    放行/拦截                       │
│                                                                                 │
│  配置：                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  .addPathPatterns("/**")              // 所有路径                        │   │
│  │  .excludePathPatterns("/user/login")  // 登录接口放行                    │   │
│  │  .excludePathPatterns("/shop/**")     // 商户接口放行                    │   │
│  │  .excludePathPatterns("/blog/hot/**") // 热榜接口放行                    │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 3. 优惠券秒杀链路

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           优惠券秒杀流程                                         │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  POST /voucher/seckill/{id}                                                     │
│                                                                                 │
│  阶段一：快速校验 (主线程执行，约1ms)                                            │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  1. 时间校验 (活动是否开始/结束)                                          │   │
│  │  2. 执行 Lua 脚本:                                                        │   │
│  │     - 库存检查                                                           │   │
│  │     - 重复下单检查                                                        │   │
│  │     - 原子扣减库存                                                        │   │
│  │  3. 生成订单ID (Redis ID Worker)                                          │   │
│  │  4. 投递消息到 RabbitMQ                                                   │   │
│  │  5. 返回订单ID给用户                                                      │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                    │                                            │
│                                    ▼                                            │
│  阶段二：异步订单创建 (MQ消费者执行，约50-100ms)                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  1. 获取 Redisson 分布式锁                                                │   │
│  │  2. 双重校验 (数据库层面):                                                │   │
│  │     - 再次检查是否重复下单                                                │   │
│  │     - 再次检查库存                                                       │   │
│  │  3. 扣减数据库库存 (UPDATE ... WHERE stock > 0)                          │   │
│  │  4. 创建订单记录                                                          │   │
│  │  5. 提交事务                                                              │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  异常处理：                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  • 库存不足 (Lua返回1) ──> 返回"优惠券已抢完"                            │   │
│  │  • 重复下单 (Lua返回2) ──> 返回"不可重复购买"                            │   │
│  │  • 消息消费失败 ──> 消息重试 / 进入死信队列                               │   │
│  │  • 库存扣减为负数 ──> 兜底方案：Redis与DB库存对账                        │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 4. 博客点赞链路

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           博客点赞流程                                           │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  PUT /blog/like/{id}                                                            │
│                                                                                 │
│  数据结构设计：                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Key: blog:like:<blogId>                                                │   │
│  │  Type: Sorted Set (ZSet)                                                │   │
│  │  Member: userId                                                         │   │
│  │  Score: UnixTimestamp (点赞时间戳)                                      │   │
│  │                                                                         │   │
│  │  优势:                                                                  │   │
│  │  • Set特性：自动去重，同一用户只能点赞一次                               │   │
│  │  • Sorted特性：按时间排序，展示最近点赞的用户                            │   │
│  │  • 高性能：Redis ZSet 操作时间复杂度 O(logN)                            │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  流程：                                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  1. ZSCORE key userId  ──> 检查是否已点赞                               │   │
│  │  2. IF 存在:                                                             │   │
│  │  │    - ZREM key userId  ──> 取消点赞                                   │   │
│  │  │    - liked - 1         ──> 更新数据库                                │   │
│  │  3. ELSE:                                                               │   │
│  │  │    - ZADD key timestamp userId  ──> 添加点赞                         │   │
│  │  │    - liked + 1         ──> 更新数据库                                │   │
│  │  4. 返回结果                                                             │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 5. 滚动分页查询（Feed流）

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           关注动态滚动分页                                       │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  GET /blog/follow?lastId=xxx&offset=2                                           │
│                                                                                 │
│  数据结构设计：                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  Key: feed:<userId>                                                     │   │
│  │  Type: Sorted Set (ZSet)                                                │   │
│  │  Member: blogId                                                         │   │
│  │  Score: blog.createTime (作为排序依据)                                  │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  滚动分页原理：                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │                                                                      │   │
│  │   时间轴:  t1 ─── t2 ─── t3 ─── t4 ─── t5 ─── t6 ─── t7             │   │
│  │            ▲                                               ▲        │   │
│  │         lastId                                            当前页      │   │
│  │                                                                      │   │
│  │   传统分页问题:                                                        │   │
│  │   • 第2页数据可能在第1页插入新数据后被挤到第3页                        │   │
│  │   • 用户刷新时看到重复内容                                             │   │
│  │                                                                      │   │
│  │   滚动分页解决方案:                                                    │   │
│  │   • 以时间戳为游标，不依赖页码                                         │   │
│  │   • ZREVRANGEBYSCORE key max lastId LIMIT offset 2                   │   │
│  │   • 返回下一页的起始时间戳作为新的lastId                               │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
│  返回结构：                                                                      │
│  ┌─────────────────────────────────────────────────────────────────────────┐   │
│  │  {                                                                      │   │
│  │    "list": [...],          // 博客列表                                  │   │
│  │    "minTime": 1702500000,  // 下一页的时间戳起点                        │   │
│  │    "offset": 3             // 偏移量，处理同时间戳多条                   │   │
│  │  }                                                                        │   │
│  └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 业务功能模块

### 👥 用户管理模块

```
┌─────────────────────────────────────┐
│           用户管理模块               │
├─────────────────────────────────────┤
│ • 邮箱注册/登录                      │
│ • 验证码频率控制 (60秒冷却)          │
│ • 用户信息管理                       │
│ • 每日签到系统 (Redis Bitmap)       │
│ • 连续签到统计                       │
│ • Token自动续期 (30分钟)            │
│ • ThreadLocal用户上下文管理          │
└─────────────────────────────────────┘
```

### 🏪 商户系统模块

```
┌─────────────────────────────────────┐
│           商户系统模块               │
├─────────────────────────────────────┤
│ • 商户信息CRUD                       │
│ • 商户分类系统                       │
│ │   ├─ 美食                          │
│ │   ├─ KTV                          │
│ │   ├─ 丽人·美发                     │
│ │   ├─ 结婚·摄影                     │
│ │   ├─ 健身·运动                     │
│ │   └─ 学习培训                      │
│ • 地理位置服务 (Redis GEO)          │
│ • 距离排序查询 (GEORADIUS)          │
│ • 缓存穿透/击穿解决方案              │
└─────────────────────────────────────┘
```

### 📝 评价系统模块

```
┌─────────────────────────────────────┐
│           评价系统模块               │
├─────────────────────────────────────┤
│ • 博客/评价发布                      │
│ • 图片上传功能 (阿里云OSS)          │
│ • 点赞系统 (Redis ZSet)            │
│ │   • 自动去重 (Set特性)            │
│ │   • 时间排序 (Score=时间戳)        │
│ • 评论功能                           │
│ • 热点博客推荐                       │
│ • 个人博客管理                       │
└─────────────────────────────────────┘
```

### 🎫 优惠券系统模块

```
┌─────────────────────────────────────┐
│          优惠券系统模块              │
├─────────────────────────────────────┤
│ • 优惠券管理                         │
│ • 秒杀优惠券                         │
│ • 库存管理 (Redis缓存)              │
│ • 分布式锁防超卖 (Redisson)         │
│ • Lua脚本原子操作                    │
│ • RabbitMQ异步处理                  │
│ • 一人一单限制                       │
└─────────────────────────────────────┘
```

### 🤝 社交功能模块

```
┌─────────────────────────────────────┐
│           社交功能模块               │
├─────────────────────────────────────┤
│ • 关注/取关功能                      │
│ • 共同关注查询                       │
│ • 朋友圈时间线 (Feed流)             │
│ • 滚动分页查询 (ZSet时间游标)       │
│ • 社交推荐算法                       │
│ • 用户签到 (Bitmap)                 │
└─────────────────────────────────────┘
```

---

## 技术栈详解

### 核心依赖

| 依赖 | 版本 | 作用 |
|------|------|------|
| Spring Boot | 3.0.1 | 应用框架 |
| Spring Boot Web | 3.0.1 | MVC 框架 |
| MyBatis Plus | 3.5.7 | ORM 框架 |
| Spring Data Redis | - | Redis 客户端 |
| Redisson | 3.13.6 | 分布式锁 |
| Spring AMQP | - | RabbitMQ 客户端 |
| Caffeine | - | 本地缓存 |
| Hutool | 5.7.17 | 工具库 |
| FastJSON2 | 2.0.51 | JSON 序列化 |
| Lombok | - | 代码生成 |

### 环境要求

| 软件 | 版本要求 | 说明 |
|------|----------|------|
| JDK | 17+ | 语言环境 |
| MySQL | 5.7+ | 主数据库 |
| Redis | 6+ | 缓存/会话 |
| RabbitMQ | 3.8+ | 消息队列 |

---

## 项目结构

```
hm-dianping/
├── src/main/java/com/hmdp/
│   ├── config/                   # 配置类
│   │   ├── RedisConfig.java      # Redisson 配置
│   │   ├── RabbitConfig.java     # RabbitMQ 配置
│   │   ├── WebMvcConfig.java     # 拦截器配置
│   │   └── WebExceptionAdvice.java # 全局异常处理
│   ├── controller/               # 控制器层
│   │   ├── UserController.java
│   │   ├── ShopController.java
│   │   ├── BlogController.java
│   │   ├── VoucherController.java
│   │   ├── VoucherOrderController.java
│   │   ├── FollowController.java
│   │   └── UploadController.java
│   ├── service/                  # 服务层
│   │   ├── impl/
│   │   │   ├── UserServiceImpl.java
│   │   │   ├── ShopServiceImpl.java
│   │   │   ├── BlogServiceImpl.java
│   │   │   ├── VoucherOrderServiceImpl.java
│   │   │   └── FollowServiceImpl.java
│   │   └── I*Service.java
│   ├── mapper/                   # 数据访问层
│   ├── domain/                   # 实体类
│   │   ├── entity/
│   │   ├── dto/
│   │   └── vo/
│   ├── constants/                # 常量定义
│   ├── utils/                    # 工具类
│   ├── redis/                    # Redis 操作封装
│   │   ├── RedisClient.java
│   │   ├── RedisIdWorker.java
│   │   ├── SimpleRedisLock.java
│   │   └── ILock.java
│   ├── interceptors/             # 拦截器
│   │   ├── RefreshInterceptor.java
│   │   └── LoginInterceptor.java
│   ├── rabbit/                   # 消息队列
│   │   ├── OrderProducer.java
│   │   └── OrderConsumer.java
│   └── oss/                      # 文件存储
├── src/main/resources/
│   ├── application.yaml          # 配置文件
│   ├── seckill.lua               # 秒杀 Lua 脚本
│   └── unlock.lua                # 解锁 Lua 脚本
└── pom.xml
```

---

## 快速开始

### 1. 环境准备

```bash
# 启动 MySQL
# 启动 Redis (端口 6379)
# 启动 RabbitMQ (端口 5673, 管理台 15672)
```

### 2. 配置修改

```yaml
# application.yaml
spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/hmdp
    username: root
    password: your_password
  data:
    redis:
      host: localhost
      port: 6379
  rabbitmq:
    host: localhost
    port: 5673
    username: admin
    password: 123456
```

### 3. 启动应用

```bash
mvn spring-boot:run
```

---

## 总结

本项目通过以下核心设计实现了高并发场景下的稳定运行：

| 设计维度 | 核心技术 | 达成效果 |
|----------|----------|----------|
| **高并发防护** | Lua脚本 + RabbitMQ + 分布式锁 | 有效防止超卖、重复下单 |
| **缓存体系** | 逻辑过期 + 空值缓存 + 多级缓存 | 解决穿透、击穿、雪崩 |
| **异步解耦** | RabbitMQ 异步处理 | 削峰填谷，提升吞吐量 |
| **一致性保障** | 最终一致性 + 多重校验 | 平衡性能与数据正确性 |
| **认证安全** | 双层拦截器 + ThreadLocal | 安全的登录态管理 |

---

**如果这个项目对你有帮助，请给个 Star 支持一下！**
